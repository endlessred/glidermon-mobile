#!/usr/bin/env python3
"""Generate per-room texture manifests from curated asset lists."""

from __future__ import annotations

import json
from pathlib import Path
from typing import Dict

from analyze_iso_asset import analyze
from PIL import Image

ROOT = Path(__file__).resolve().parents[4]
EXPORT_ROOT = ROOT / "src" / "assets" / "Isometric" / "Ultimate_Isometric_Interior" / "Exports"
PROCESSED_ROOT = ROOT / "src" / "assets" / "Isometric" / "Ultimate_Isometric_Interior" / "Processed"
ROOMS_DIR = ROOT / "src" / "game" / "housing" / "assets" / "rooms"
MANIFEST_DIR = ROOT / "src" / "game" / "housing" / "assets" / "generated"

CATEGORY_MODES: Dict[str, str] = {
    "FloorTiles": "floor",
    "WallTiles": "wall",
}

SCRIPT_HEADER = """// AUTO-GENERATED by process_room_assets.py
// Do not edit manually.

export type RoomAtlasMode = 'floor' | 'wall' | 'auto';

export interface RoomAtlasEntry {
  id: string;
  category: string;
  theme: string | null;
  name: string;
  mode: RoomAtlasMode;
  requirePath: any;
  metadata: {
    sourcePath: string;
    originalSize: { width: number; height: number };
    trimmedRect: { x: number; y: number; width: number; height: number };
    contactY: number | null;
    skirt: number | null;
    constants: Record<string, number>;
    notes: string;
  };
}

"""


def slugify(text: str) -> str:
    import re
    text = text.replace("&", " and ")
    text = re.sub(r"[^0-9a-zA-Z]+", "_", text)
    text = re.sub(r"_+", "_", text)
    return text.strip("_").lower()


def make_atlas_id(category: str, stem: str) -> str:
    if category == "FloorTiles" and stem.startswith("WoodFloor_"):
        return f"floor_wood_{slugify(stem[len('WoodFloor_') :])}"
    if category == "WallTiles" and stem.startswith("WoodWall_"):
        return f"wall_wood_{slugify(stem[len('WoodWall_') :])}"
    return slugify(f"{category}_{stem}")


def ensure_parent(path: Path) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)


def process_asset(rel_path: str):
    source_path = EXPORT_ROOT / rel_path
    if not source_path.exists():
        print(f"Missing asset: {source_path}")
        return None

    parts = Path(rel_path).parts
    category = parts[0] if len(parts) > 0 else "Unknown"
    theme = parts[1] if len(parts) > 1 else None
    stem = Path(rel_path).stem
    mode = CATEGORY_MODES.get(category, "auto")

    analysis = analyze(str(source_path), mode=mode, alpha_thresh=0, override_skirt=None)
    if analysis.bbox.w == 0 or analysis.bbox.h == 0:
        print(f"Skipping {source_path} (empty bbox)")
        return None

    img = Image.open(source_path)
    crop_box = (
        analysis.bbox.x,
        analysis.bbox.y,
        analysis.bbox.x + analysis.bbox.w,
        analysis.bbox.y + analysis.bbox.h,
    )
    cropped = img.crop(crop_box)

    processed_path = PROCESSED_ROOT / rel_path
    ensure_parent(processed_path)
    cropped.save(processed_path)

    require_rel = Path("../../../../assets/Isometric/Ultimate_Isometric_Interior/Processed") / rel_path
    source_rel = Path("../../../../assets/Isometric/Ultimate_Isometric_Interior/Exports") / rel_path

    return {
        "id": make_atlas_id(category, stem),
        "category": category,
        "theme": theme,
        "name": stem,
        "mode": mode,
        "requirePath": str(require_rel).replace("\\", "/"),
        "metadata": {
            "sourcePath": str(source_rel).replace("\\", "/"),
            "originalSize": {"width": analysis.canvas_w, "height": analysis.canvas_h},
            "trimmedRect": {
                "x": analysis.bbox.x,
                "y": analysis.bbox.y,
                "width": analysis.bbox.w,
                "height": analysis.bbox.h,
            },
            "contactY": analysis.contact_y_auto,
            "skirt": analysis.skirt_auto,
            "constants": analysis.constants,
            "notes": analysis.notes,
        },
    }


def write_manifest(room_id: str, entries, description: str | None = None) -> None:
    manifest_path = MANIFEST_DIR / f"{room_id}AtlasManifest.ts"
    ensure_parent(manifest_path)

    entries = sorted(entries, key=lambda entry: entry["id"])

    with manifest_path.open("w", encoding="utf-8") as f:
        f.write(SCRIPT_HEADER)
        if description:
            f.write(f"// Room: {description}\n\n")
        const_name = f"{room_id}AtlasManifest"
        f.write(f"export const {const_name}: RoomAtlasEntry[] = [\n")
        for entry in entries:
            f.write("  {\n")
            f.write(f"    id: '{entry['id']}',\n")
            f.write(f"    category: '{entry['category']}',\n")
            f.write(f"    theme: {json.dumps(entry['theme'])},\n")
            f.write(f"    name: '{entry['name']}',\n")
            f.write(f"    mode: '{entry['mode']}',\n")
            f.write(f"    requirePath: require('{entry['requirePath']}'),\n")
            metadata_json = json.dumps(entry["metadata"], indent=6)
            metadata_lines = metadata_json.splitlines()
            f.write("    metadata: " + metadata_lines[0] + "\n")
            for line in metadata_lines[1:]:
                f.write("      " + line + "\n")
            f.write("  },\n")
        f.write("]\n")


def main() -> None:
    ensure_parent(MANIFEST_DIR)
    if not ROOMS_DIR.exists():
        raise SystemExit(f"Rooms directory not found: {ROOMS_DIR}")

    for config_path in sorted(ROOMS_DIR.glob('*.json')):
        data = json.loads(config_path.read_text(encoding='utf-8-sig'))
        room_id = data.get('id') or config_path.stem
        description = data.get('description')
        assets = data.get('assets', [])
        if not assets:
            print(f"No assets listed for {config_path}")
            continue

        entries = []
        for rel in assets:
            entry = process_asset(rel)
            if entry:
                entries.append(entry)
        write_manifest(room_id, entries, description)


if __name__ == '__main__':
    main()

