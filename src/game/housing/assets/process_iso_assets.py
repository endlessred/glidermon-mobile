#!/usr/bin/env python3
"""Process Ultimate Isometric Interior PNG assets: crop, save to Processed/, and emit a manifest."""

from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Dict, Iterable

from analyze_iso_asset import analyze
from PIL import Image

ROOT = Path(__file__).resolve().parents[4]
EXPORT_ROOT = ROOT / "src" / "assets" / "Isometric" / "Ultimate_Isometric_Interior" / "Exports"
PROCESSED_ROOT = ROOT / "src" / "assets" / "Isometric" / "Ultimate_Isometric_Interior" / "Processed"
MANIFEST_TS = ROOT / "src" / "game" / "housing" / "assets" / "generated" / "isoAtlasManifest.ts"

CATEGORY_MODES: Dict[str, str] = {
    "FloorTiles": "floor",
    "WallTiles": "wall",
}

IGNORED_PREFIXES: Iterable[str] = ("._",)

ALLOWED_THEMES: Dict[str, set[str]] = {
    "FloorTiles": {"Brown1"},
    "WallTiles": {"Brown1"},
}
ALLOWED_CATEGORIES = set(ALLOWED_THEMES.keys())



def slugify(text: str) -> str:
    text = text.replace("&", " and ")
    text = re.sub(r"[^0-9a-zA-Z]+", "_", text)
    text = re.sub(r"_+", "_", text)
    return text.strip("_").lower()


def build_id(parts: Iterable[str]) -> str:
    return "_".join(slugify(part) for part in parts if part)



def make_atlas_id(category: str, theme: str | None, stem: str) -> str:
    if category == "FloorTiles":
        suffix = stem[len("WoodFloor_"):] if stem.startswith("WoodFloor_") else stem
        return f"floor_wood_{slugify(suffix)}"
    if category == "WallTiles":
        suffix = stem[len("WoodWall_"):] if stem.startswith("WoodWall_") else stem
        return f"wall_wood_{slugify(suffix)}"
    parts = [category]
    if theme:
        parts.append(theme)
    parts.append(stem)
    return build_id(parts)

def ensure_dirs() -> None:
    PROCESSED_ROOT.mkdir(parents=True, exist_ok=True)
    MANIFEST_TS.parent.mkdir(parents=True, exist_ok=True)


def process_asset(source_path: Path):
    rel_path = source_path.relative_to(EXPORT_ROOT)
    parts = rel_path.parts
    category = parts[0] if len(parts) > 0 else "Unknown"
    theme = parts[1] if len(parts) > 2 else None

    if category not in ALLOWED_CATEGORIES:
        return None
    allowed_themes = ALLOWED_THEMES.get(category)
    if allowed_themes and (theme not in allowed_themes):
        return None

    stem = source_path.stem
    if category == "FloorTiles" and not stem.startswith("WoodFloor_"):
        return None
    if category == "WallTiles" and not stem.startswith("WoodWall_"):
        return None

    mode = CATEGORY_MODES.get(category, "auto")

    try:
        analysis = analyze(str(source_path), mode=mode, alpha_thresh=0, override_skirt=None)
    except Exception as exc:  # pylint: disable=broad-except
        print(f"Skipping {source_path} (analysis failed: {exc})")
        return None

    if analysis.bbox.w == 0 or analysis.bbox.h == 0:
        print(f"Skipping {source_path} (empty bbox)")
        return None

    img = Image.open(source_path)
    crop_box = (
        analysis.bbox.x,
        analysis.bbox.y,
        analysis.bbox.x + analysis.bbox.w,
        analysis.bbox.y + analysis.bbox.h,
    )
    cropped = img.crop(crop_box)

    processed_path = PROCESSED_ROOT / rel_path
    processed_path.parent.mkdir(parents=True, exist_ok=True)
    cropped.save(processed_path)

    atlas_id = make_atlas_id(category, theme, source_path.stem)

    require_rel = Path("../../../../assets/Isometric/Ultimate_Isometric_Interior/Processed") / rel_path
    source_rel = Path("../../../../assets/Isometric/Ultimate_Isometric_Interior/Exports") / rel_path

    return {
        "id": atlas_id,
        "category": category,
        "theme": theme,
        "name": source_path.stem,
        "mode": mode,
        "requirePath": str(require_rel).replace("\\", "/"),
        "metadata": {
            "sourcePath": str(source_rel).replace("\\", "/"),
            "originalSize": {"width": analysis.canvas_w, "height": analysis.canvas_h},
            "trimmedRect": {
                "x": analysis.bbox.x,
                "y": analysis.bbox.y,
                "width": analysis.bbox.w,
                "height": analysis.bbox.h,
            },
            "contactY": analysis.contact_y_auto,
            "skirt": analysis.skirt_auto,
            "constants": analysis.constants,
            "notes": analysis.notes,
        },
    }


def write_manifest(entries):
    entries.sort(key=lambda entry: entry["id"])
    with MANIFEST_TS.open("w", encoding="utf-8") as manifest:
        manifest.write("// AUTO-GENERATED by process_iso_assets.py\n")
        manifest.write("// Do not edit manually.\n\n")
        manifest.write("export type IsoAtlasMode = 'floor' | 'wall' | 'auto';\n\n")
        manifest.write("export interface IsoAtlasEntry {\n")
        manifest.write("  id: string;\n")
        manifest.write("  category: string;\n")
        manifest.write("  theme: string | null;\n")
        manifest.write("  name: string;\n")
        manifest.write("  mode: IsoAtlasMode;\n")
        manifest.write("  requirePath: any;\n")
        manifest.write("  metadata: {\n")
        manifest.write("    sourcePath: string;\n")
        manifest.write("    originalSize: { width: number; height: number };\n")
        manifest.write("    trimmedRect: { x: number; y: number; width: number; height: number };\n")
        manifest.write("    contactY: number | null;\n")
        manifest.write("    skirt: number | null;\n")
        manifest.write("    constants: Record<string, number>;\n")
        manifest.write("    notes: string;\n")
        manifest.write("  };\n")
        manifest.write("}\n\n")
        manifest.write("export const isoAtlasManifest: IsoAtlasEntry[] = [\n")
        for entry in entries:
            manifest.write("  {\n")
            manifest.write(f"    id: '{entry['id']}',\n")
            manifest.write(f"    category: '{entry['category']}',\n")
            manifest.write(f"    theme: {json.dumps(entry['theme'])},\n")
            manifest.write(f"    name: '{entry['name']}',\n")
            manifest.write(f"    mode: '{entry['mode']}',\n")
            manifest.write(f"    requirePath: require('{entry['requirePath']}'),\n")
            metadata_json = json.dumps(entry["metadata"], indent=6)
            metadata_lines = metadata_json.splitlines()
            manifest.write("    metadata: " + metadata_lines[0] + "\n")
            for line in metadata_lines[1:]:
                manifest.write("      " + line + "\n")
            manifest.write("  },\n")
        manifest.write("]\n")


def main() -> None:
    ensure_dirs()
    png_files = sorted(EXPORT_ROOT.rglob("*.png"))
    if not png_files:
        raise SystemExit(f"No PNG assets found under {EXPORT_ROOT}")

    entries = []
    for source_path in png_files:
        if any(source_path.name.startswith(prefix) for prefix in IGNORED_PREFIXES):
            continue
        entry = process_asset(source_path)
        if entry:
            entries.append(entry)
    write_manifest(entries)


if __name__ == '__main__':
    main()

